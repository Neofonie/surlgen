options {
    STATIC = false ;
}

PARSER_BEGIN(UrlMappingParser)
package de.neofonie.surlgen.urlmapping.parser;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

public class UrlMappingParser {

    public static UrlPattern parse( String expression ) throws ParseException, TokenMgrError {
        UrlMappingParser parser = new UrlMappingParser( new StringReader(expression) ) ;
        return parser.start();
    }
}
PARSER_END(UrlMappingParser)

//http://eriklievaart.com/blog/javacc2.html

SKIP:  { " " | "\t" | "\n" | "\r"                    }
TOKEN: {
// < PARAM : (["a"-"z", "A"-"Z"])+ > |
 < MAPS: "{">: MAPPING
 | < ANYTHING : (~["{", "}", "[", "]"])+ >
}

<MAPPING> TOKEN: {
    < PARAM : (["a"-"z", "A"-"Z"])+ >
    | <MAP : ":">
    | <END : "}">:DEFAULT
}

private AbstractUrlPattern start(): {AbstractUrlPattern t;} {
    t = tokenList() <EOF>
    {return t;}
}

private AbstractUrlPattern tokenList(): {AbstractUrlPattern p; List<AbstractUrlPattern> list = new ArrayList();} {
    ( p = token() { list.add(p); } )+
    { return PatternList.create(list); }
}

private AbstractUrlPattern token(): {Token t; AbstractUrlPattern p;} {
    ( "[" p = tokenList() "]" { return new Choice(p); }
    | "{" p = mapping() <END> { return p; }
    | p = anything() { return p; }
    )
}

private AbstractUrlPattern choice(): {AbstractUrlPattern p;} {
    "[" p = anything() "]" { return new Choice(p); }
}

private AbstractUrlPattern mapping(): {Token name;Token type;} {
    name = <PARAM> <MAP> type = <PARAM> { return new Mapping(name.image, type.image); }
}

private AbstractUrlPattern anything(): {Token t; StringBuilder sb = new StringBuilder();} {
 t = <ANYTHING>
 { return new StaticUrlPattern(t.image); }
}